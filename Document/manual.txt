嗯，听说大家要写OS Kernel，我在这里提供一些基本的指导（按照x86-64+UEFI引导的路子）首先确定（阶段性的）目标，以下可供参考0. 在屏幕上显示点什么东西1. 不借助外力(UEFI执行环境)完成上述目标2. 从键盘上读入点东西3. 把内存管理起来，在自己管理的内存上完成上述目标4. 离开内核态，在用户态完成上述目标5. 使用一个单独的进程完成上述目标6. 实现Terminal和Shell的功能7. 文件系统？多用户？GUI？……Step -0.5. 准备知识：计算机的引导原理，UEFI是什么Step 0. 准备编译运行UEFI应用所用的工具（GCC+QEMU），参照https://wiki.osdev.org/UEFI和https://wiki.osdev.org/UEFI_Bare_Bones，这时候可以跑一个Hello World了Step 0.5. 准备知识：UEFI的Boot Service和Runtime Service是什么，如何离开UEFI环境（退出Boot Service），如何获得帧缓冲(Frame Buffer)的地址，Step 1. 退出UEFI的Boot Service，通过直接写Frame Buffer来显示文字（可以使用PSF字体：https://wiki.osdev.org/PC_Screen_Font）Step 2. 了解PS/2键盘的操作方法，读入键盘输入并回显到屏幕上Step 2.5. 准备知识：什么是页表，x86-64的四级页表格式，ELF文件的基本格式；准备工具：GCC交叉编译器，参照https://wiki.osdev.org/GCC_Cross-CompilerStep 2.9. 使用GCC编译一个内核，包含一个不做任何事情的kernel_main函数；在UEFI程序中准备好初始页表，将编译出来的ELF程序加载到内存，并跳转到kernel_main函数Step 2.95. 准备知识：操作系统管理内存的几种方式Step 3. 完成一个物理内存和页表管理器，应该至少支持(1) map映射一段虚拟内存到空闲物理地址或指定物理地址 (2) unmap释放一段映射的虚拟内存Extra: Meltdown漏洞的原理是什么，操作系统怎样规避这个漏洞？Step 3.5. 准备知识：正常情况下，操作系统的代码何时被执行？如何处理中断？系统调用如何实现？Step 4. 完成一个中断处理程序；从磁盘加载一个程序进入内存并跳转到用户态（磁盘加载可以在之前的UEFI引导器中实现，从磁盘加载一个文件作为初始时的文件系统(类似initramfs) ）；使用中断的方式处理键盘输入Step 5. 完成一个进程调度器；同时载入多个进程进行运行Step 6. 实现一个Terminal，用管道(stdin, stdout)向进程传递输入输出数据；实现一个Shell，提供一些最基本的命令参考资料：1. 拥有自制操作系统所用的各种资料的OSDev WIKI: https://wiki.osdev.org/Main_Page2. UEFI相关资料的Phoenix WIKI: http://wiki.phoenix.com/wiki/index.php/Main_Page3. x86-64和处理器相关文档: https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf